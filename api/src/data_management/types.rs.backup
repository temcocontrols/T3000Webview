use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

/// Device information (T3-BB devices)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Device {
   /// Configuration for data manager
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataManagerConfig {
    pub database_path: String,
    pub t3000_output_path: String,
    pub cache_duration_seconds: i32,
    pub background_poll_interval_seconds: i32,
    pub max_batch_size: usize,
    pub enable_background_collection: bool,
    pub data_retention_days: Option<i32>,
}

/// Data statistics for monitoring point
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataStatistics {
    pub count: u64,
    pub min_value: Option<f64>,
    pub max_value: Option<f64>,
    pub avg_value: Option<f64>,
    pub first_timestamp: Option<i64>,
    pub last_timestamp: Option<i64>,
}tion<i32>,
    pub device_id: i32,
    pub device_name: String,
    pub device_type: String,
    pub status: i32,
    pub last_seen: i64,
    pub created_at: Option<i64>,
}

/// Monitoring point definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MonitoringPoint {
    pub id: Option<i32>,
    pub device_id: i32,
    pub point_type: i32,
    pub point_number: i32,
    pub point_category: String,
    pub label: Option<String>,
    pub description: Option<String>,
    pub unit_code: Option<i32>,
    pub unit_symbol: Option<String>,
    pub is_active: i32,
    pub created_at: Option<i64>,
    pub updated_at: Option<i64>,
}

/// Trend log configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TrendLog {
    pub id: Option<i32>,
    pub device_id: i32,
    pub trend_log_index: i32,
    pub log_id: String,
    pub label: Option<String>,
    pub hour_interval_time: i32,
    pub minute_interval_time: i32,
    pub second_interval_time: i32,
    pub status: i32,
    pub is_active: i32,
    pub created_at: Option<i64>,
    pub updated_at: Option<i64>,
}

impl TrendLog {
    /// Calculate total interval in seconds
    pub fn total_interval_seconds(&self) -> i32 {
        self.hour_interval_time * 3600 +
        self.minute_interval_time * 60 +
        self.second_interval_time
    }
}

/// Trend log item assignment (14 items per trend log)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TrendLogItem {
    pub id: Option<i32>,
    pub trend_log_id: i32,
    pub item_index: i32,
    pub device_id: i32,
    pub point_type: i32,
    pub point_number: i32,
    pub is_active: i32,
    pub created_at: Option<i64>,
}

/// Real-time data cache entry
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RealtimeDataCache {
    pub id: Option<i32>,
    pub device_id: i32,
    pub point_type: i32,
    pub point_number: i32,
    pub value: f64,
    pub timestamp: i64,
    pub data_type: String,
    pub unit_code: Option<i32>,
    pub is_fresh: i32,
    pub cache_duration: i32,
    pub created_at: Option<i64>,
    pub updated_at: Option<i64>,
}

impl RealtimeDataCache {
    /// Check if data is still fresh based on cache duration
    pub fn is_data_fresh(&self) -> bool {
        let now = Utc::now().timestamp();
        (now - self.timestamp) <= self.cache_duration as i64
    }
}

/// Time series data point
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimeSeriesData {
    pub id: Option<i32>,
    pub device_id: i32,
    pub point_type: i32,
    pub point_number: i32,
    pub trend_log_id: Option<i32>,
    pub value: f64,
    pub timestamp: i64,
    pub interval_seconds: i32,
    pub data_quality: i32,
}

/// Data point for API responses
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataPoint {
    pub device_id: i32,
    pub point_type: i32,
    pub point_number: i32,
    pub value: f64,
    pub timestamp: i64,
    pub data_type: String,
    pub unit_code: Option<i32>,
    pub unit_symbol: Option<String>,
    pub description: Option<String>,
}

/// API request for time series data
#[derive(Debug, Deserialize)]
pub struct TimeSeriesRequest {
    pub start_time: i64,
    pub end_time: i64,
    pub interval_seconds: Option<i32>,
    pub trend_log_id: Option<i32>,
}

/// API response for time series data
#[derive(Debug, Serialize)]
pub struct TimeSeriesResponse {
    pub data: Vec<TimeSeriesData>,
    pub total_points: usize,
    pub start_time: i64,
    pub end_time: i64,
    pub interval_seconds: i32,
    pub device_info: Option<Device>,
    pub point_info: Option<MonitoringPoint>,
}

/// API response wrapper
#[derive(Debug, Serialize)]
pub struct ApiResponse<T> {
    pub success: bool,
    pub data: Option<T>,
    pub error: Option<String>,
    pub timestamp: i64,
    pub source: String, // "cache", "t3000", "database"
}

impl<T> ApiResponse<T> {
    pub fn success(data: T, source: &str) -> Self {
        Self {
            success: true,
            data: Some(data),
            error: None,
            timestamp: Utc::now().timestamp(),
            source: source.to_string(),
        }
    }

    pub fn error(error: &str) -> Self {
        Self {
            success: false,
            data: None,
            error: Some(error.to_string()),
            timestamp: Utc::now().timestamp(),
            source: "error".to_string(),
        }
    }
}

/// Configuration for the data management system
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataManagerConfig {
    pub database_path: String,
    pub t3000_output_path: String,
    pub cache_duration_seconds: i32,
    pub background_poll_interval_seconds: i32,
    pub max_batch_size: usize,
    pub enable_background_collection: bool,
    pub data_retention_days: Option<i32>,
}

impl Default for DataManagerConfig {
    fn default() -> Self {
        Self {
            database_path: "D:\\1025\\github\\temcocontrols\\T3000_Building_Automation_System\\T3000 Output\\Debug\\Database\\webview_data_cache.db".to_string(),
            t3000_output_path: "D:\\1025\\github\\temcocontrols\\T3000_Building_Automation_System\\T3000 Output\\Debug".to_string(),
            cache_duration_seconds: 60,
            background_poll_interval_seconds: 30,
            max_batch_size: 1000,
            enable_background_collection: true,
            data_retention_days: None, // No limit by default
        }
    }
}

/// Data statistics for monitoring point
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataStatistics {
    pub count: u64,
    pub min_value: Option<f64>,
    pub max_value: Option<f64>,
    pub avg_value: Option<f64>,
    pub first_timestamp: Option<i64>,
    pub last_timestamp: Option<i64>,
}
