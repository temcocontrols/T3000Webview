<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Boolean Operations with Paper.js</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.15/paper-full.min.js"></script>
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .controls {
      display: flex;
      flex-direction: column;
      margin-bottom: 10px;
    }

    canvas {
      border: 1px solid black;
      width: 50vw;
      height: 70vh;
    }

    #log {
      width: 80vw;
      height: 30vh;
      border: 1px solid black;
      overflow-y: scroll;
      margin-top: 10px;
    }
  </style>
</head>

<body>
  <div class="controls">
    <div style="display: flex; flex-direction: column;">
      <div style="display: flex; gap: 10px; margin-bottom: 10px;">
        <input type="file" id="fileInput1" accept=".svg">
        <input type="file" id="fileInput2" accept=".svg">
        <textarea id="svgString1" placeholder="Paste SVG string here..."></textarea>
        <textarea id="svgString2" placeholder="Paste SVG string here..."></textarea>
      </div>
      <div style="display: flex; gap: 10px; margin-top: 10px;">
        <button id="custom">Custom</button>
        <button id="unionButton">Union</button>
        <button id="differenceButton">Difference</button>
        <button id="xorButton">XOR</button>
        <button id="intersectionButton">Intersection</button>
        <button id="clearButton">Clear</button>
      </div>
    </div>
  </div>
  <div style="display: flex; gap: 10px; margin-left: 120px;margin-right: 120px;">
    <canvas id="myCanvas1" resize stats></canvas>
    <canvas id="myCanvas2" resize stats></canvas>
  </div>
  <div id="log"></div>
  <script>
    // paper.setup('myCanvas1');
    // paper.setup('myCanvas2');

    const canvas1 = document.getElementById('myCanvas1');
    const canvas2 = document.getElementById('myCanvas2');

    const project1 = new paper.Project(canvas1);
    const project2 = new paper.Project(canvas2);

    // console.log('project1', project1);
    // console.log('project2', project2);

    /*
    // test load from svg string and export it to svg without boolean, to check if the import functionality is working
    const loadAndExportSVGFromString = (svgString) => {
      //single self test
      svgString = `
      <svg data-v-f50b06a6="" data-v-633ad4c9="" viewBox="0 0 20.921802 20.921802" version="1.1"
        xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns="http://www.w3.org/2000/svg"
        xmlns:svg="http://www.w3.org/2000/svg" height="40" width="50" class="object-svg heatpump" titleColor="inherit"
        bgColor="inherit" textColor="inherit" fontSize="16"
        style="transform: translate(10px, 40px) rotate(-277.1476441551531deg); --f50b06a6-fillColor: #659dc5;">
        <g fill="#659dc5" transform="translate(-5.4940996,-5.5390997)" data-v-f50b06a6="">
          <g class="pump" data-v-f50b06a6="">
            <circle stroke="#000000" cy="16" cx="15.955" r="9.9609003" class="pump-background" data-v-f50b06a6=""></circle>
            <g transform="translate(16,16)" data-v-f50b06a6="">
              <path d="M -5,8.1369 V -8.1191 L 9.078,0.0091 Z" class="rotating-middle" stroke="#000000" stroke-width="0.96719"
                data-v-f50b06a6=""></path>
            </g>
          </g>
        </g>
      </svg>
      `;

      const item = paper.project.importSVG(svgString);
      const svg = paper.project.exportSVG({ asString: true });
      console.log('loadAndExportSVGFromString', svg);
      return svg;
    };


    // //svg import and export
    // loadAndExportSVGFromString("");

    */


    // Function to load all paths from an item suitable for Paper.js format
    const loadAllPathsFromItem = (item) => {
      let paths = [];

      console.log('item', item);
      if (item instanceof paper.Path || item instanceof paper.CompoundPath || item instanceof paper.Path.Circle) {
        paths.push(item);
      } else if (item instanceof paper.Group) {
        item.children.forEach(child => {
          paths = paths.concat(loadAllPathsFromItem(child));
        });
      } else if (item.children) {
        item.children.forEach(child => {
          paths = paths.concat(loadAllPathsFromItem(child));
        });
      }
      return paths;
    };


    /**/

    const unitePathsFromArray = (shapesArray) => {
      let combinedPath = null;

      const processShape = (shape) => {

        // console.log('shape is a clippath', shape.isClipMask());
        // console.log('shape-id-type-outer', shape.id, shape.type);

        if (shape.type == "circle") {
          console.log('shape is a circle outer', shape.id, shape);
        }

        if (shape instanceof paper.Path || paper.ClipPath || paper.type == 'circle') {
          console.log('any output', shape.id, shape)
          if (shape.type == "circle") {
            console.log('shape is a circle outer', shape.id, shape);
          }

          if (combinedPath) {

            combinedPath = combinedPath.unite(shape, { insert: true });
          } else {
            combinedPath = shape;
          }
        } else if (shape instanceof paper.Group) {
          // combinedPath = combinedPath.unite(shape);
          shape.children.forEach(child => processShape(child));

          //only unite the first object
          // shape.children[0].strokeColor = 'red';
          // combinedPath = combinedPath.unite(shape.lastChild);

        } else if (shape instanceof paper.CompoundPath) {
          shape.children.forEach(child => processShape(child));
        }
      };

      shapesArray.forEach(shape => processShape(shape));

      if (combinedPath) {
        // combinedPath.fillColor = '#659dc5';
        // combinedPath.strokeColor = 'black';
        // combinedPath.strokeWidth = 2;
      }

      return combinedPath;
    };

    const getCombinedPath = (shapes) => {
      let combinedPath = shapes[0];
      console.log('shapes', shapes);

      shapes.map(shape => {
        console.log('shape', shape);
        console.log('shape', shape.pathData);
      });

      var rest1 = shapes.slice(1);
      console.log('shapes.slice(1)', rest1);

      rest1.forEach(shape => {
        if (shape instanceof paper.Path) {
          combinedPath = combinedPath.unite(shape);
        } else if (shape instanceof paper.Circle) {
          console.log('getCombinedPath shape is a circle', shape);
          combinedPath = combinedPath.unite(shape);
        }
        else
          if (shape instanceof paper.Group) {
            console.log('shape is a group', shape);

            // all united
            shape.children.forEach(item => {
              console.log('item', item);
              combinedPath = combinedPath.unite(item);
            });


            // not working for the group shape
            // combinedPath = combinedPath.reduce((acc, item) => acc.unite(item), combinedPath.firstChild);

            // only merge the first child
            // combinedPath = combinedPath.unite(shape.firstChild);

            // only merge the last child
            // combinedPath = combinedPath.unite(shape.lastChild);

          }
      });

      // combinedPath.fillColor = '#659dc5';
      // combinedPath.strokeColor = 'black';
      // combinedPath.strokeWidth = 2;

      return combinedPath;
    };

    const svgStringToPath = (svgString) => {

      // get pump d data and transfer it to path
      svgString = `
      <svg data-v-f50b06a6="" data-v-633ad4c9="" viewBox="0 0 20.921802 20.921802" version="1.1"
        xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns="http://www.w3.org/2000/svg"
        xmlns:svg="http://www.w3.org/2000/svg" height="40" width="50" class="object-svg heatpump" titleColor="inherit"
        bgColor="inherit" textColor="inherit" fontSize="16"
        style="transform: translate(10px, 40px) rotate(-277.1476441551531deg); --f50b06a6-fillColor: #659dc5;">
        <g fill="#659dc5" transform="translate(-5.4940996,-5.5390997)" data-v-f50b06a6="">
          <g class="pump" data-v-f50b06a6="">
            <circle stroke="#000000" cy="16" cx="15.955" r="9.9609003" class="pump-background" data-v-f50b06a6=""></circle>
            <g transform="translate(16,16)" data-v-f50b06a6="">
              <path d="M -5,8.1369 V -8.1191 L 9.078,0.0091 Z" class="rotating-middle" stroke="#000000" stroke-width="0.96719"
                data-v-f50b06a6=""></path>
            </g>
          </g>
        </g>
      </svg>
      `;

      const parser = new DOMParser();
      const svgDoc = parser.parseFromString(svgString, 'image/svg+xml');
      const pathElements = svgDoc.querySelectorAll('path');
      const paths = [];

      pathElements.forEach(pathElement => {
        const pathData = pathElement.getAttribute('d');
        if (pathData) {
          const path = new paper.Path(pathData);
          paths.push(path);
        }
      });

      return paths;
    };

    const loadSVGFromStringToPath = (svgString, svgName) => {
      const item = project1.importSVG(svgString, { applyMatrix: true });
      console.log('load svg=', svgName, item);
      return item;
    };

    const boilerSvgString = `
          <svg data-v-2593cf62="" data-v-633ad4c9="" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" height="67" width="89"
            version="1.1" class="object-svg boiler" titleColor="inherit" bgColor="inherit" textColor="inherit" fontSize="16"
            style="--2593cf62-fillColor: #659dc5;" transform="rotate(61.00519680642214)">
            <path data-v-2593cf62=""
              style="fill: #659dc5; fill-opacity: 1; fill-rule: nonzero; stroke: rgb(0, 0, 0);
          stroke-width: 1px; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1;"
              d="m 2,15 8,-7 0,-7 12,0 0,7 8,7 0,16 -28,0 z"></path>
          </svg>
          `;

    const pumpSvgString = `
        <svg data-v-f50b06a6="" data-v-633ad4c9="" viewBox="0 0 20.921802 20.921802" version="1.1"
          xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns="http://www.w3.org/2000/svg"
          xmlns:svg="http://www.w3.org/2000/svg" height="40" width="50" class="object-svg heatpump" titleColor="inherit"
          bgColor="inherit" textColor="inherit" fontSize="16"
          style="transform: translate(10px, 40px) rotate(-277.1476441551531deg); --f50b06a6-fillColor: #659dc5;">
          <g fill="#659dc5" transform="translate(-5.4940996,-5.5390997)" data-v-f50b06a6="">
            <g class="pump" data-v-f50b06a6="">
              <circle stroke="#000000" cy="16" cx="15.955" r="9.9609003" class="pump-background" data-v-f50b06a6=""></circle>
              <g transform="translate(16,16)" data-v-f50b06a6="">
                <path d="M -5,8.1369 V -8.1191 L 9.078,0.0091 Z" class="rotating-middle" stroke="#000000" stroke-width="0.96719"
                  data-v-f50b06a6=""></path>
              </g>
            </g>
          </g>
        </svg>
          `;

    const coolingSvgString = `
<svg data-v-6dfb81bf="" data-v-633ad4c9="" height="100%" width="100%" version="1.1" viewBox="0 0 10.423067 22.852614" xmlns="http://www.w3.org/2000/svg" class="object-svg temperature" titleColor="inherit" bgColor="inherit" textColor="inherit" fontSize="16" style="transform: translate(890.6319326px, 177.7014465px) rotate(77.96233497908918deg); --6dfb81bf-fillColor: #659dc5;"><g id="layer1" stroke="#000000" stroke-width="1px" transform="translate(-10.804626,-9.2243756)" data-v-6dfb81bf=""><rect id="rect3012" height="14.505" width="2.901" y="9.9127998" x="14.557" fill="#ffff00" data-v-6dfb81bf=""></rect><path id="path3010" stroke-width="1.2px" transform="matrix(0.74098,0,0,0.74098,7.3047,15.679)" fill="#659dc5" d="m 17.949,15.898 -3.1021,5.373 H 8.6427 L 5.5406,15.898 8.6427,10.525 h 6.2042 z" data-v-6dfb81bf=""></path></g><g id="g4141" transform="translate(-1.2033861,-8.1217684)" data-v-6dfb81bf=""><circle r="0.77312505" cy="28.129852" cx="6.4061227" id="path4137" style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.5;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;" data-v-6dfb81bf=""></circle><path id="path4139" d="M 6.4061205,27.157211 V 23.65349" style="fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:0.5;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;" data-v-6dfb81bf=""></path></g></svg>          `;

    const filterSvgString = `
<svg data-v-5bf45a7d="" data-v-633ad4c9="" viewBox="0 0 13 29" height="100%" width="100%" version="1.1" xmlns="http://www.w3.org/2000/svg" class="object-svg filter" titleColor="inherit" bgColor="inherit" textColor="inherit" fontSize="16" style="transform: translate(1075.1666666666665px, 105.91666666666666px) rotate(54.716685817785105deg); --5bf45a7d-fillColor: #659dc5;"><g data-v-5bf45a7d="" stroke="#000" stroke-width="1" transform="matrix(1, 0, 0, 1, -9.37, -1.3252)"><rect data-v-5bf45a7d="" id="rect4367" height="27.35" width="11.26" y="2.3252" x="10.37" fill="#659dc5"></rect><path data-v-5bf45a7d="" id="path3756" stroke-linejoin="miter" d="m11.892,2.6997,8.2165,4.4334-8.2165,4.4334,8.2165,4.4334-8.2165,4.4334,8.2165,4.4334-8.2165,4.4334" stroke-linecap="round" stroke-miterlimit="4" stroke-dasharray="none" stroke-width="1.2694304" fill="none"></path></g></svg>
`;

    const createShapes = () => {
      const shapes = [];
      var operations = ['unite', 'intersect', 'subtract', 'exclude', 'divide'];

      // pumpLastD = svgStringToPath("");
      // console.log('pumpLastD', pumpLastD);

      // Create three different shapes with different colors
      const shape1 = new paper.Path.Circle({
        center: [150, 150],
        radius: 50,
        fillColor: '#7f5ea7',
        name: 'shape1-Circle'
      });

      const shape2 = new paper.Path.Rectangle({
        point: [200, 100],
        size: [100, 100],
        fillColor: 'green',
        name: 'shape2-Rectangle'
      });

      const shape3 = new paper.Path.Ellipse({
        point: [250, 150],
        size: [150, 100],
        fillColor: 'blue',
        name: 'shape3-Ellipse'
      });

      var originals = new paper.Group({ insert: false, name: 'originals-Group' }); // Don't insert in DOM.

      // console.log('originals', originals);

      var square = new paper.Path.Rectangle({
        center: [380, 80],
        size: 100,
        parent: originals,
        fillColor: '#f2d3d3',
        name: 'originals-Square-Rectangle'
      });

      // console.log('square', square);

      // Make a ring using subtraction of two circles:
      var inner = new paper.Path.Circle({
        center: [380, 80],
        radius: 50,
        parent: originals,
        fillColor: '#c94949',
        name: 'originals-Inner-Circle'
      });

      // console.log('inner', inner);

      var outer = new paper.Path.Circle({
        center: [380, 60],
        radius: 30,
        parent: originals,
        fillColor: '#b49595',
        name: 'originals-Outer-Circle'
      });

      // console.log('outer', outer);


      // load pump svg from string
      // var pumpSvg = loadSVGFromStringToPath(pumpSvgString, 'pumpSvg');
      // console.log('pumpSvg', pumpSvg);

      // var boilerSvg = loadSVGFromStringToPath(boilerSvgString, 'boilerSvg');
      // console.log('boilerSvg', boilerSvg);

      // var coolingSvg = loadSVGFromStringToPath(coolingSvgString, 'coolingSvg');
      // console.log('coolingSvg', coolingSvg);

      // var filterSvg = loadSVGFromStringToPath(filterSvgString, 'filterSvg');
      // console.log('filterSvg', filterSvg);

      //shape1, shape2, shape3, originals pumpSvg

      // shapes.push(boilerSvg, pumpSvg, coolingSvg, filterSvg);
      shapes.push(shape1, shape2, shape3, originals);

      // Add shapes to the canvas
      shapes.forEach(shape => {
        project1.activeLayer.addChild(shape);
        console.log('after add child project1.activelayer', shape.name);
        console.log(project1);
        console.log(project1.layers.length);
        console.log(project1.layers);
      });

      // Function to perform boolean operations dynamically
      const performDynamicBooleanOperation = () => {

        // let combinedPath = getCombinedPath(shapes);
        let combinedPath = unitePathsFromArray(shapes);

        combinedPath.onMouseDrag = function (event) {
          this.position = this.position.add(event.delta);
          // performDynamicBooleanOperation();
        };

        project1.activeLayer.addChild(combinedPath);
        project1.view.draw();
      };

      // Enable dragging for each shape and perform boolean operations dynamically
      shapes.forEach(shape => {

        shape.onMouseDrag = function (event) {
          this.position = this.position.add(event.delta);
          // performDynamicBooleanOperation();
        };

        shape.onMouseUp = function (event) {
          // this.position = this.position.add(event.delta);
          performDynamicBooleanOperation();
        };
      });

      // performDynamicBooleanOperation();
    };

    createShapes();

    /**/

    let shapes2 = [];

    // Function to log details
    const logDetails = (message) => {
      const log = document.getElementById('log');
      log.innerHTML += `<p>${message}</p>`;
      log.scrollTop = log.scrollHeight;
    };

    // Function to load SVG from FileReader
    const loadSVGFromFile = (file) => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const svgContent = e.target.result;
          project2.importSVG(svgContent, item => {
            // console.log('item', item);
            resolve({ item, svgContent });
          });
        };
        reader.onerror = (e) => reject(e);
        reader.readAsText(file);
      });
    };

    // Function to load SVG from string
    const loadSVGFromString = (svgContent) => {
      return new Promise((resolve) => {
        project2.importSVG(svgContent, item => {
          resolve({ item, svgContent });
        });
      });
    };

    // Function to extract all properties of an SVG item
    const extractSVGProperties = (item) => {
      const properties = {};

      if (item instanceof paper.Path || item instanceof paper.CompoundPath) {
        properties.type = 'path';
        properties.pathData = item.pathData;
      } else if (item instanceof paper.Shape) {
        properties.type = 'shape';
        if (item.shape === 'rectangle') {
          properties.shape = 'rectangle';
          properties.size = item.size;
          properties.radius = item.radius;
        } else if (item.shape === 'circle') {
          properties.shape = 'circle';
          properties.radius = item.radius;
        } else if (item.shape === 'ellipse') {
          properties.shape = 'ellipse';
          properties.size = item.size;
        }
      } else if (item instanceof paper.Group) {
        properties.type = 'group';
        properties.children = item.children.map(child => extractSVGProperties(child));
      } else if (item instanceof paper.Raster) {
        properties.type = 'raster';
        properties.source = item.source;
      }

      properties.position = item.position;
      properties.rotation = item.rotation;
      properties.scaling = item.scaling;
      properties.strokeColor = item.strokeColor;
      properties.fillColor = item.fillColor;

      return properties;
    };

    // Function to extract paths from SVG item
    const extractPaths1 = (item) => {
      let paths = [];
      if (item instanceof paper.Path || item instanceof paper.CompoundPath) {
        paths.push(item);
      } else if (item.children) {
        item.children.forEach(child => {
          paths = paths.concat(extractPaths1(child));
        });
      }
      return paths;
    };

    // Function to perform boolean operations
    const performBooleanOperation = (operation) => async () => {
      const fileInput1 = document.getElementById('fileInput1').files[0];
      const fileInput2 = document.getElementById('fileInput2').files[0];
      const svgString1 = document.getElementById('svgString1').value;
      const svgString2 = document.getElementById('svgString2').value;

      try {
        let svgItem1, svgContent1, svgItem2, svgContent2;

        if (fileInput1) {
          const result = await loadSVGFromFile(fileInput1);
          svgItem1 = result.item;
          svgContent1 = result.svgContent;
        } else if (svgString1) {
          const result = await loadSVGFromString(svgString1);
          svgItem1 = result.item;
          svgContent1 = result.svgContent;
        }

        if (fileInput2) {
          const result = await loadSVGFromFile(fileInput2);
          svgItem2 = result.item;
          svgContent2 = result.svgContent;
        } else if (svgString2) {
          const result = await loadSVGFromString(svgString2);
          svgItem2 = result.item;
          svgContent2 = result.svgContent;
        }

        if (svgItem1 && svgItem2) {
          logDetails(`Loaded SVG1: ${svgContent1}`);
          logDetails(`Loaded SVG2: ${svgContent2}`);

          //test to set the same properties as T3000 user selected
          console.log('svgItem1', svgItem1);
          console.log('svgItem2', svgItem2);

          /*
          var item = paper.project.activeLayer.children[0];
          var rotation = item.matrix.values[0];
          var angle = Math.acos(rotation) * (180 / Math.PI);

          var cx = item.matrix.values[4];
          var cy = item.matrix.values[5];

          console.log('rotation angle:', angle, 'rotation center:', cx, cy);
          */

          //rest the rotation and scale and position manually

          svgItem1.position = new paper.Point(100, 100);
          svgItem1.width = 152.31666564941406;
          svgItem1.height = 152.31666564941406;
          svgItem1.rotate(61.00519680642214);
          svgItem1.scale(1);

          svgItem2.position = new paper.Point(120, 120);
          svgItem2.width = 67;
          svgItem2.height = 67;
          svgItem2.rotate(-277.1476441551531);
          svgItem2.scale(1);

          // Extract paths
          const paths1 = loadAllPathsFromItem(svgItem1);
          const paths2 = loadAllPathsFromItem(svgItem2);

          // const paths1c = extractPaths1(svgItem1);
          // const paths2c = extractPaths1(svgItem2);

          // console.log('paths1-n', paths1);
          // console.log('paths2-n', paths2);

          console.log('paths1', paths1);
          console.log('paths2', paths2);

          if (paths1.length === 0 || paths2.length === 0) {
            throw new Error("No valid paths found in one or both SVG files.");
          }

          // Perform the boolean operation on each path
          let combinedPath = paths1[0];
          paths1.slice(1).forEach(path => combinedPath = combinedPath.unite(path));
          paths2.forEach(path => {
            switch (operation) {
              case 'union':
                combinedPath = combinedPath.unite(path);
                break;
              case 'difference':
                combinedPath = combinedPath.subtract(path);
                break;
              case 'xor':
                combinedPath = combinedPath.exclude(path);
                break;
              case 'intersection':
                combinedPath = combinedPath.intersect(path);
                break;
              default:
                throw new Error("Unknown operation");
            }
          });

          // Handle groups in paths1
          paths1.forEach(path => {
            if (path instanceof paper.Group) {
              path.children.forEach(child => {
                switch (operation) {
                  case 'union':
                    combinedPath = combinedPath.unite(child);
                    break;
                  case 'difference':
                    combinedPath = combinedPath.subtract(child);
                    break;
                  case 'xor':
                    combinedPath = combinedPath.exclude(child);
                    break;
                  case 'intersection':
                    combinedPath = combinedPath.intersect(child);
                    break;
                  default:
                    throw new Error("Unknown operation");
                }
              });
            }
          });

          // Handle groups in paths2
          paths2.forEach(path => {
            if (path instanceof paper.Group) {
              path.children.forEach(child => {
                switch (operation) {
                  case 'union':
                    combinedPath = combinedPath.unite(child);
                    break;
                  case 'difference':
                    combinedPath = combinedPath.subtract(child);
                    break;
                  case 'xor':
                    combinedPath = combinedPath.exclude(child);
                    break;
                  case 'intersection':
                    combinedPath = combinedPath.intersect(child);
                    break;
                  default:
                    throw new Error("Unknown operation");
                }
              });
            }
          });

          /*
          // Perform the boolean operation on each path
          let combinedPath = paths1[0];
          paths1.slice(1).forEach(path => combinedPath = combinedPath.unite(path));
          paths2.forEach(path => {
            switch (operation) {
              case 'union':
                combinedPath = combinedPath.unite(path);
                break;
              case 'difference':
                combinedPath = combinedPath.subtract(path);
                break;
              case 'xor':
                combinedPath = combinedPath.exclude(path);
                break;
              case 'intersection':
                combinedPath = combinedPath.intersect(path);
                break;
              default:
                throw new Error("Unknown operation");
            }
          });
          */

          // combinedPath.fillColor = null;
          // combinedPath.strokeColor = 'black';
          // combinedPath.strokeWidth = 2;

          shapes2.push(combinedPath);

          // Enable dragging for the combined path
          combinedPath.onMouseDrag = function (event) {
            this.position = this.position.add(event.delta);
          };

          // Add the combined path to the canvas
          project2.activeLayer.addChild(combinedPath);
          paper.view.draw();

          logDetails(`Operation: ${operation}`);
          logDetails(`Combined Path: ${combinedPath.pathData}`);
        } else {
          alert("Please provide two SVG files or strings.");
        }
      } catch (error) {
        console.error('Error loading SVG files:', error);
        logDetails(`Error: ${error.message}`);
      }
    };

    // Clear function
    const clearInputs = () => {
      document.getElementById('fileInput1').value = '';
      document.getElementById('fileInput2').value = '';
      document.getElementById('svgString1').value = '';
      document.getElementById('svgString2').value = '';
      document.getElementById('log').innerHTML = '';
      shapes2.forEach(shape => shape.remove());
      shapes2 = [];
      paper.project.clear();
      paper.view.draw();
    };

    document.getElementById('unionButton').onclick = performBooleanOperation('union');
    document.getElementById('differenceButton').onclick = performBooleanOperation('difference');
    document.getElementById('xorButton').onclick = performBooleanOperation('xor');
    document.getElementById('intersectionButton').onclick = performBooleanOperation('intersection');
    document.getElementById('clearButton').onclick = clearInputs;
    document.getElementById('custom').onclick = createShapes;
  </script>
</body>

</html>