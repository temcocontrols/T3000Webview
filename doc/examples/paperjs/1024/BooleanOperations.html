<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Boolean Operations with Paper.js</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.15/paper-full.min.js"></script>
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .controls {
      display: flex;
      flex-direction: column;
      margin-bottom: 10px;
    }

    canvas {
      border: 1px solid black;
      width: 50vw;
      height: 70vh;
    }

    #log {
      width: 80vw;
      height: 30vh;
      border: 1px solid black;
      overflow-y: scroll;
      margin-top: 10px;
    }
  </style>
</head>

<body>
  <div class="controls">
    <div style="display: flex; flex-direction: column;">
      <div style="display: flex; gap: 10px; margin-bottom: 10px;">
        <input type="file" id="fileInput1" accept=".svg">
        <input type="file" id="fileInput2" accept=".svg">
        <textarea id="svgString1" placeholder="Paste SVG string here..."></textarea>
        <textarea id="svgString2" placeholder="Paste SVG string here..."></textarea>
      </div>
      <div style="display: flex; gap: 10px; margin-top: 10px;">
        <button id="custom">Custom</button>
        <button id="unionButton">Union</button>
        <button id="differenceButton">Difference</button>
        <button id="xorButton">XOR</button>
        <button id="intersectionButton">Intersection</button>
        <button id="clearButton">Clear</button>
      </div>
    </div>
  </div>
  <div style="display: flex; gap: 10px; margin-left: 120px;margin-right: 120px;">
    <canvas id="myCanvas1" resize stats></canvas>
    <canvas id="myCanvas"></canvas>
  </div>
  <div id="log"></div>
  <script>
    paper.setup('myCanvas');
    paper.setup('myCanvas1');

    const canvas1 = document.getElementById('myCanvas1');
    const canvas2 = document.getElementById('myCanvas');

    const project1 = new paper.Project(canvas1);
    const project2 = new paper.Project(canvas2);

    console.log('project1', project1);
    console.log('project2', project2);


    // Function to load all paths from an item suitable for Paper.js format
    const loadAllPathsFromItem = (item) => {
      let paths = [];
      if (item instanceof paper.Path || item instanceof paper.CompoundPath) {
        paths.push(item);
      } else if (item instanceof paper.Group) {
        item.children.forEach(child => {
          paths = paths.concat(loadAllPathsFromItem(child));
        });
      } else if (item.children) {
        item.children.forEach(child => {
          paths = paths.concat(loadAllPathsFromItem(child));
        });
      }
      return paths;
    };


    /**/

    const unitePathsFromArray = (shapesArray) => {
      let combinedPath = null;

      const processShape = (shape) => {
        if (shape instanceof paper.Path) {
          if (combinedPath) {
            combinedPath = combinedPath.unite(shape);
          } else {
            combinedPath = shape;
          }
        } else if (shape instanceof paper.Group) {
          shape.children.forEach(child => processShape(child));
        } else if (shape instanceof paper.CompoundPath) {
          shape.children.forEach(child => processShape(child));
        }
      };

      shapesArray.forEach(shape => processShape(shape));

      if (combinedPath) {
        combinedPath.fillColor = '#659dc5';
        combinedPath.strokeColor = 'black';
        combinedPath.strokeWidth = 2;
      }

      return combinedPath;
    };

    const getCombinedPath = (shapes) => {
      let combinedPath = shapes[0];
      console.log('shapes', shapes);

      shapes.map(shape => {
        console.log('shape', shape);
        console.log('shape', shape.pathData);
      });

      var rest1 = shapes.slice(1);
      console.log('shapes.slice(1)', rest1);

      rest1.forEach(shape => {
        if (shape instanceof paper.Path) {
          combinedPath = combinedPath.unite(shape);
        } else
          if (shape instanceof paper.Group) {
            console.log('shape is a group', shape);

            // all united
            shape.children.forEach(item => {
              console.log('item', item);
              combinedPath = combinedPath.unite(item);
            });

            /*
            // not working for the group shape
            //  combinedPath = combinedPath.reduce((acc, item) => acc.unite(item), combinedPath.firstChild);

            // only merge the first child
            combinedPath = combinedPath.unite(shape.firstChild);

            // only merge the last child
            combinedPath=combinedPath.unite(shape.lastChild);
            */
          }
      });

      combinedPath.fillColor = '#659dc5';
      combinedPath.strokeColor = 'black';
      combinedPath.strokeWidth = 2;

      return combinedPath;
    };


    const svgStringToPath = (svgString) => {

      // get pump d data and transfer it to path
      svgString = `
      <svg data-v-f50b06a6="" data-v-633ad4c9="" viewBox="0 0 20.921802 20.921802" version="1.1"
        xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns="http://www.w3.org/2000/svg"
        xmlns:svg="http://www.w3.org/2000/svg" height="40" width="50" class="object-svg heatpump" titleColor="inherit"
        bgColor="inherit" textColor="inherit" fontSize="16"
        style="transform: translate(10px, 40px) rotate(-277.1476441551531deg); --f50b06a6-fillColor: #659dc5;">
        <g fill="#659dc5" transform="translate(-5.4940996,-5.5390997)" data-v-f50b06a6="">
          <g class="pump" data-v-f50b06a6="">
            <circle stroke="#000000" cy="16" cx="15.955" r="9.9609003" class="pump-background" data-v-f50b06a6=""></circle>
            <g transform="translate(16,16)" data-v-f50b06a6="">
              <path d="M -5,8.1369 V -8.1191 L 9.078,0.0091 Z" class="rotating-middle" stroke="#000000" stroke-width="0.96719"
                data-v-f50b06a6=""></path>
            </g>
          </g>
        </g>
      </svg>
      `;

      const parser = new DOMParser();
      const svgDoc = parser.parseFromString(svgString, 'image/svg+xml');
      const pathElements = svgDoc.querySelectorAll('path');
      const paths = [];

      pathElements.forEach(pathElement => {
        const pathData = pathElement.getAttribute('d');
        if (pathData) {
          const path = new paper.Path(pathData);
          paths.push(path);
        }
      });

      return paths;
    };

    const loadSVGFromStringToPath = (svgString) => {

      svgString = `
      <svg data-v-f50b06a6="" data-v-633ad4c9="" viewBox="0 0 20.921802 20.921802" version="1.1"
        xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns="http://www.w3.org/2000/svg"
        xmlns:svg="http://www.w3.org/2000/svg" height="40" width="50" class="object-svg heatpump" titleColor="inherit"
        bgColor="inherit" textColor="inherit" fontSize="16"
        style="transform: translate(10px, 40px) rotate(-277.1476441551531deg); --f50b06a6-fillColor: #659dc5;">
        <g fill="#659dc5" transform="translate(-5.4940996,-5.5390997)" data-v-f50b06a6="">
          <g class="pump" data-v-f50b06a6="">
            <circle stroke="#000000" cy="16" cx="15.955" r="9.9609003" class="pump-background" data-v-f50b06a6=""></circle>
            <g transform="translate(16,16)" data-v-f50b06a6="">
              <path d="M -5,8.1369 V -8.1191 L 9.078,0.0091 Z" class="rotating-middle" stroke="#000000" stroke-width="0.96719"
                data-v-f50b06a6=""></path>
            </g>
          </g>
        </g>
      </svg>
      `;

      const item = paper.project.importSVG(svgString);
      // const paths = loadAllPathsFromItem(item);
      return item;
    };

    const createShapes = () => {
      const shapes = [];
      var operations = ['unite', 'intersect', 'subtract', 'exclude', 'divide'];

      pumpLastD = svgStringToPath("");
      console.log('pumpLastD', pumpLastD);

      // Create three different shapes with different colors
      const shape1 = new paper.Path.Circle({
        center: [150, 150],
        radius: 50,
        fillColor: '#659dc5'
      });

      const shape2 = new paper.Path.Rectangle({
        point: [200, 100],
        size: [100, 100],
        fillColor: 'green'
      });

      const shape3 = new paper.Path.Ellipse({
        point: [250, 150],
        size: [150, 100],
        fillColor: 'blue'
      });

      var originals = new paper.Group({ insert: false }); // Don't insert in DOM.

      console.log('originals', originals);

      var square = new paper.Path.Rectangle({
        center: [380, 80],
        size: 100,
        parent: originals,
        fillColor: '#191313'
      });

      console.log('square', square);

      // Make a ring using subtraction of two circles:
      var inner = new paper.Path.Circle({
        center: [420, 60],
        radius: 50,
        parent: originals,
        fillColor: '#c94949'
      });

      console.log('inner', inner);

      var outer = new paper.Path.Circle({
        center: [420, 60],
        radius: 30,
        parent: originals,
        fillColor: '#b49595'
      });

      console.log('outer', outer);


      // load pump svg from string
      var pumpSvg = loadSVGFromStringToPath("");

      //originals

      shapes.push(shape1, shape2, shape3, pumpSvg);

      // Add shapes to the canvas
      shapes.forEach(shape => project1.activeLayer.addChild(shape));

      // Function to perform boolean operations dynamically
      const performDynamicBooleanOperation = () => {

        // let combinedPath = getCombinedPath(shapes);
        let combinedPath = unitePathsFromArray(shapes);

        combinedPath.onMouseDrag = function (event) {
          this.position = this.position.add(event.delta);
          // performDynamicBooleanOperation();
        };

        project1.activeLayer.addChild(combinedPath);
        project1.view.draw();
      };

      // Enable dragging for each shape and perform boolean operations dynamically
      shapes.forEach(shape => {

        shape.onMouseDrag = function (event) {
          this.position = this.position.add(event.delta);
          // performDynamicBooleanOperation();
        };

        shape.onMouseUp = function (event) {
          // this.position = this.position.add(event.delta);
          performDynamicBooleanOperation();
        };
      });

      // performDynamicBooleanOperation();
    };

    createShapes();

    /**/

    let shapes = [];

    // Function to log details
    const logDetails = (message) => {
      const log = document.getElementById('log');
      log.innerHTML += `<p>${message}</p>`;
      log.scrollTop = log.scrollHeight;
    };

    // Function to load SVG from FileReader
    const loadSVGFromFile = (file) => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const svgContent = e.target.result;
          paper.project.importSVG(svgContent, item => {
            // console.log('item', item);
            resolve({ item, svgContent });
          });
        };
        reader.onerror = (e) => reject(e);
        reader.readAsText(file);
      });
    };

    // Function to load SVG from string
    const loadSVGFromString = (svgContent) => {
      return new Promise((resolve) => {
        paper.project.importSVG(svgContent, item => {
          resolve({ item, svgContent });
        });
      });
    };

    // Function to extract all properties of an SVG item
    const extractSVGProperties = (item) => {
      const properties = {};

      if (item instanceof paper.Path || item instanceof paper.CompoundPath) {
        properties.type = 'path';
        properties.pathData = item.pathData;
      } else if (item instanceof paper.Shape) {
        properties.type = 'shape';
        if (item.shape === 'rectangle') {
          properties.shape = 'rectangle';
          properties.size = item.size;
          properties.radius = item.radius;
        } else if (item.shape === 'circle') {
          properties.shape = 'circle';
          properties.radius = item.radius;
        } else if (item.shape === 'ellipse') {
          properties.shape = 'ellipse';
          properties.size = item.size;
        }
      } else if (item instanceof paper.Group) {
        properties.type = 'group';
        properties.children = item.children.map(child => extractSVGProperties(child));
      } else if (item instanceof paper.Raster) {
        properties.type = 'raster';
        properties.source = item.source;
      }

      properties.position = item.position;
      properties.rotation = item.rotation;
      properties.scaling = item.scaling;
      properties.strokeColor = item.strokeColor;
      properties.fillColor = item.fillColor;

      return properties;
    };

    // Function to extract paths from SVG item
    const extractPaths1 = (item) => {
      let paths = [];
      if (item instanceof paper.Path || item instanceof paper.CompoundPath) {
        paths.push(item);
      } else if (item.children) {
        item.children.forEach(child => {
          paths = paths.concat(extractPaths1(child));
        });
      }
      return paths;
    };



    // Function to perform boolean operations
    const performBooleanOperation = (operation) => async () => {
      const fileInput1 = document.getElementById('fileInput1').files[0];
      const fileInput2 = document.getElementById('fileInput2').files[0];
      const svgString1 = document.getElementById('svgString1').value;
      const svgString2 = document.getElementById('svgString2').value;

      try {
        let svgItem1, svgContent1, svgItem2, svgContent2;

        if (fileInput1) {
          const result = await loadSVGFromFile(fileInput1);
          svgItem1 = result.item;
          svgContent1 = result.svgContent;
        } else if (svgString1) {
          const result = await loadSVGFromString(svgString1);
          svgItem1 = result.item;
          svgContent1 = result.svgContent;
        }

        if (fileInput2) {
          const result = await loadSVGFromFile(fileInput2);
          svgItem2 = result.item;
          svgContent2 = result.svgContent;
        } else if (svgString2) {
          const result = await loadSVGFromString(svgString2);
          svgItem2 = result.item;
          svgContent2 = result.svgContent;
        }

        if (svgItem1 && svgItem2) {
          logDetails(`Loaded SVG1: ${svgContent1}`);
          logDetails(`Loaded SVG2: ${svgContent2}`);

          //test to set the same properties as T3000 user selected
          console.log('svgItem1', svgItem1);
          console.log('svgItem2', svgItem2);

          /*
          var item = paper.project.activeLayer.children[0];
          var rotation = item.matrix.values[0];
          var angle = Math.acos(rotation) * (180 / Math.PI);

          var cx = item.matrix.values[4];
          var cy = item.matrix.values[5];

          console.log('rotation angle:', angle, 'rotation center:', cx, cy);
          */

          //rest the rotation and scale and position manually

          svgItem1.position = new paper.Point(100, 100);
          svgItem1.width = 152.31666564941406;
          svgItem1.height = 152.31666564941406;
          svgItem1.rotate(61.00519680642214);
          svgItem1.scale(1);

          svgItem2.position = new paper.Point(120, 120);
          svgItem2.width = 67;
          svgItem2.height = 67;
          svgItem2.rotate(-277.1476441551531);
          svgItem2.scale(1);

          // Extract paths
          const paths1 = loadAllPathsFromItem(svgItem1);
          const paths2 = loadAllPathsFromItem(svgItem2);

          const paths1c = extractPaths1(svgItem1);
          const paths2c = extractPaths1(svgItem2);

          // console.log('paths1-n', paths1);
          // console.log('paths2-n', paths2);

          console.log('paths1', paths1);
          console.log('paths2', paths2);

          if (paths1.length === 0 || paths2.length === 0) {
            throw new Error("No valid paths found in one or both SVG files.");
          }

          // Perform the boolean operation on each path
          let combinedPath = paths1[0];
          paths1.slice(1).forEach(path => combinedPath = combinedPath.unite(path));
          paths2.forEach(path => {
            switch (operation) {
              case 'union':
                combinedPath = combinedPath.unite(path);
                break;
              case 'difference':
                combinedPath = combinedPath.subtract(path);
                break;
              case 'xor':
                combinedPath = combinedPath.exclude(path);
                break;
              case 'intersection':
                combinedPath = combinedPath.intersect(path);
                break;
              default:
                throw new Error("Unknown operation");
            }
          });

          // Handle groups in paths1
          paths1.forEach(path => {
            if (path instanceof paper.Group) {
              path.children.forEach(child => {
                switch (operation) {
                  case 'union':
                    combinedPath = combinedPath.unite(child);
                    break;
                  case 'difference':
                    combinedPath = combinedPath.subtract(child);
                    break;
                  case 'xor':
                    combinedPath = combinedPath.exclude(child);
                    break;
                  case 'intersection':
                    combinedPath = combinedPath.intersect(child);
                    break;
                  default:
                    throw new Error("Unknown operation");
                }
              });
            }
          });

          // Handle groups in paths2
          paths2.forEach(path => {
            if (path instanceof paper.Group) {
              path.children.forEach(child => {
                switch (operation) {
                  case 'union':
                    combinedPath = combinedPath.unite(child);
                    break;
                  case 'difference':
                    combinedPath = combinedPath.subtract(child);
                    break;
                  case 'xor':
                    combinedPath = combinedPath.exclude(child);
                    break;
                  case 'intersection':
                    combinedPath = combinedPath.intersect(child);
                    break;
                  default:
                    throw new Error("Unknown operation");
                }
              });
            }
          });

          /*
          // Perform the boolean operation on each path
          let combinedPath = paths1[0];
          paths1.slice(1).forEach(path => combinedPath = combinedPath.unite(path));
          paths2.forEach(path => {
            switch (operation) {
              case 'union':
                combinedPath = combinedPath.unite(path);
                break;
              case 'difference':
                combinedPath = combinedPath.subtract(path);
                break;
              case 'xor':
                combinedPath = combinedPath.exclude(path);
                break;
              case 'intersection':
                combinedPath = combinedPath.intersect(path);
                break;
              default:
                throw new Error("Unknown operation");
            }
          });
          */

          // combinedPath.fillColor = null;
          // combinedPath.strokeColor = 'black';
          // combinedPath.strokeWidth = 2;

          shapes.push(combinedPath);

          // Enable dragging for the combined path
          combinedPath.onMouseDrag = function (event) {
            this.position = this.position.add(event.delta);
          };

          // Add the combined path to the canvas
          paper.project.activeLayer.addChild(combinedPath);
          paper.view.draw();

          logDetails(`Operation: ${operation}`);
          logDetails(`Combined Path: ${combinedPath.pathData}`);
        } else {
          alert("Please provide two SVG files or strings.");
        }
      } catch (error) {
        console.error('Error loading SVG files:', error);
        logDetails(`Error: ${error.message}`);
      }
    };

    // Clear function
    const clearInputs = () => {
      document.getElementById('fileInput1').value = '';
      document.getElementById('fileInput2').value = '';
      document.getElementById('svgString1').value = '';
      document.getElementById('svgString2').value = '';
      document.getElementById('log').innerHTML = '';
      shapes.forEach(shape => shape.remove());
      shapes = [];
      paper.project.clear();
      paper.view.draw();
    };

    document.getElementById('unionButton').onclick = performBooleanOperation('union');
    document.getElementById('differenceButton').onclick = performBooleanOperation('difference');
    document.getElementById('xorButton').onclick = performBooleanOperation('xor');
    document.getElementById('intersectionButton').onclick = performBooleanOperation('intersection');
    document.getElementById('clearButton').onclick = clearInputs;
    document.getElementById('custom').onclick = createShapes;
  </script>
</body>

</html>
