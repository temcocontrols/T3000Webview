<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Boolean Operations with Paper.js</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.15/paper-full.min.js"></script>
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
    }

    .canvas-container {
      display: flex;
      justify-content: space-between;
      width: 100vw;
      height: 100vh;
    }

    canvas {
      border: 1px solid black;
      width: 50vw;
      height: 100vh;
    }

    #svgContainer {
      width: 40vw;
      height: 90vh;
      overflow: auto;
      border-left: 1px solid black;
    }

    .controls {
      display: flex;
      justify-content: space-between;
      width: 100vw;
      padding: 10px;
    }
  </style>
</head>

<body>
  <div class="controls">
    <input type="file" id="fileInput1" accept=".svg">
    <input type="file" id="fileInput2" accept=".svg">
    <textarea id="svgStringInput1" class="svg-input" placeholder="Enter SVG string 1"></textarea>
    <textarea id="svgStringInput2" class="svg-input" placeholder="Enter SVG string 2"></textarea>
    <br>
    <button id="unionButton">Union</button>
    <button id="differenceButton">Difference</button>
    <button id="xorButton">XOR</button>
    <button id="intersectionButton">Intersection</button>
    <button id="clearButton">Clear</button>
  </div>
  <div class="canvas-container">
    <canvas id="myCanvas" resize></canvas>
    <div id="svgContainer">
      <div id="svgDisplay1"></div>
      <div id="svgDisplay2"></div>
    </div>
  </div>
  <script>
    paper.setup('myCanvas');

    // Function to load SVG from FileReader
    const loadSVGFromFile = (file) => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const svgContent = e.target.result;
          paper.project.importSVG(svgContent, item => {
            resolve({ item, svgContent });
          });
        };
        reader.onerror = (e) => reject(e);
        reader.readAsText(file);
      });
    };


    // Function to load SVG from string
    const loadSVGFromString = (svgString) => {
      return new Promise((resolve) => {
        // paper.project.importSVG(svgString, item => {
        //   resolve(item);
        // }) ;

        paper.project.importSVG(svgString, item => {
          item.position = paper.view.center;
          item.applyMatrix = true;

          resolve(item);
        });

        paper.view.draw();

      });
    };


    // // Function to load SVG from FileReader
    // const loadSVGFromFile = (file) => {
    //   return new Promise((resolve, reject) => {
    //     const reader = new FileReader();
    //     reader.onload = (e) => {
    //       const svgContent = e.target.result;
    //       // paper.project.importSVG(svgContent, item => {
    //       //   resolve({ item, svgContent });
    //       // });
    //       loadSVGFromString(svgContent).then(result => resolve(result));
    //     };
    //     reader.onerror = (e) => reject(e);
    //     reader.readAsText(file);
    //   });
    // };

    // Function to display original SVG in the container
    const displayOriginalSVG = (svgContent, containerId) => {
      const container = document.getElementById(containerId);
      container.innerHTML = svgContent;
    };

    // Function to extract paths from SVG item
    const extractPaths = (item) => {
      let paths = [];
      if (item instanceof paper.Path || item instanceof paper.CompoundPath) {
        paths.push(item);
      } else if (item.children) {
        item.children.forEach(child => {
          paths = paths.concat(extractPaths(child));
        });
      }
      return paths;
    };

    // Function to perform boolean operations
    const performBooleanOperation = (operation) => async () => {
      const fileInput1 = document.getElementById('fileInput1').files[0];
      const fileInput2 = document.getElementById('fileInput2').files[0];
      const svgString1 = document.getElementById('svgStringInput1').value;
      const svgString2 = document.getElementById('svgStringInput2').value;

      let svgItem1, svgItem2, svgContent1, svgContent2;

      if (fileInput1) {
        const result1 = await loadSVGFromFile(fileInput1);
        svgItem1 = result1.item;
        svgContent1 = result1.svgContent;
      } else if (svgString1) {
        svgItem1 = await loadSVGFromString(svgString1);
        svgContent1 = svgString1;
      }

      if (fileInput2) {
        const result2 = await loadSVGFromFile(fileInput2);
        svgItem2 = result2.item;
        svgContent2 = result2.svgContent;
      } else if (svgString2) {
        svgItem2 = await loadSVGFromString(svgString2);
        svgContent2 = svgString2;
      }

      if (svgItem1 && svgItem2) {
        try {
          const { item: svgItem1, svgContent: svgContent1 } = await loadSVGFromFile(fileInput1);
          const { item: svgItem2, svgContent: svgContent2 } = await loadSVGFromFile(fileInput2);

          // Display original SVGs
          displayOriginalSVG(svgContent1, 'svgDisplay1');
          displayOriginalSVG(svgContent2, 'svgDisplay2');

          // Extract paths
          const paths1 = extractPaths(svgItem1);
          const paths2 = extractPaths(svgItem2);

          console.log('Paths 1:', paths1);
          console.log('Paths 2:', paths2);

          if (paths1.length === 0 || paths2.length === 0) {
            throw new Error("No valid paths found in one or both SVG files.");
          }

          // Perform the boolean operation on each path
          let combinedPath = paths1[0];
          paths1.slice(1).forEach(path => combinedPath = combinedPath.unite(path));
          paths2.forEach(path => {
            switch (operation) {
              case 'union':
                combinedPath = combinedPath.unite(path);
                break;
              case 'difference':
                combinedPath = combinedPath.subtract(path);
                break;
              case 'xor':
                combinedPath = combinedPath.exclude(path);
                break;
              case 'intersection':
                combinedPath = combinedPath.intersect(path);
                break;
              default:
                throw new Error("Unknown operation");
            }
          });

          combinedPath.strokeColor = 'black';
          combinedPath.strokeWidth = 2;


          console.log('Combined path:', combinedPath);

          // Add the combined path to the canvas
          paper.project.activeLayer.addChild(combinedPath);
          paper.view.draw();
        } catch (error) {
          console.error('Error loading SVG files:', error);
        }
      } else {
        alert("Please select two SVG files.");
      }
    };

    // Clear function
    const clearInputs = () => {
      console.log("clearing inputs");
      document.getElementById('fileInput1').value = '';
      document.getElementById('fileInput2').value = '';
      // document.getElementById('svgString1').value = '';
      // document.getElementById('svgString2').value = '';
      document.getElementById('svgDisplay1').innerHTML = '';
      document.getElementById('svgDisplay2').innerHTML = '';
      paper.project.clear();
      paper.view.draw();
    };


    document.getElementById('unionButton').onclick = performBooleanOperation('union');
    document.getElementById('differenceButton').onclick = performBooleanOperation('difference');
    document.getElementById('xorButton').onclick = performBooleanOperation('xor');
    document.getElementById('intersectionButton').onclick = performBooleanOperation('intersection');
    document.getElementById('clearButton').onclick = clearInputs();
  </script>
</body>

</html>
