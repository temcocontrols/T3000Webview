<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SVG Boolean Operations</title>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.15/paper-full.min.js"></script>
  <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/js-clipper/6.4.2/clipper.min.js"></script> -->
  <script src="doc/html/Javascript_Clipper_6.4.2.2/clipper_unminified.js"></script>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    canvas {
      border: 1px solid black;
      margin-top: 10px;
      width: 100vw;
      height: 100vh;
    }

    textarea {
      width: 300px;
      height: 100px;
      margin-top: 10px;
    }
  </style>
</head>

<body>
  <h1>SVG Boolean Operations</h1>
  <label for="upload">Upload SVG:</label>
  <input type="file" id="upload" accept=".svg" title="Upload SVG file" />
  <textarea id="svgString" placeholder="Paste SVG here"></textarea>
  <button id="loadSvg">Load SVG</button>
  <button id="union">Union</button>
  <button id="union2">Union2</button>
  <button id="difference">Difference</button>
  <button id="intersection">Intersection</button>
  <button id="subtraction">Subtraction</button>
  <canvas id="canvas" resize></canvas>

  <script>
    paper.setup('canvas');
    const polygons = [];
    let selectedItem = null;

    var svg1 = `<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">
                    <rect x="10" y="10" width="80" height="80" fill="blue" />
                </svg>`;

    var svg2 = `<svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
                    <rect x="20" y="20" width="160" height="160" fill="red" />
                </svg> `;

    var svg3 = `<svg width="300" height="300" xmlns="http://www.w3.org/2000/svg">
                <path d="M100,20 A80,80 0 1,0 100,180 A80,80 0 1,0 100,20" fill="#d8c2c2" />
                 </svg>`;

    // const defaultSvg1 = '<path d="M10 10 H 110 V 60 H 10 Z" fill="red" />'; // Red rectangle as a path
    // const defaultSvg2 = '<path d="M20 20 H 150 V 100 H 20 Z" fill="blue" />'; // Blue rectangle as a larger path
    var defaultSvg3 = '<path d="M50,10 A40,40 0 1,0 50,90 A40,40 0 1,0 50,10" fill="green" />'; // Green circle

    // Default SVG strings
    var defaultSvg1 = `<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">
                                <path d="M10 10 H 90 V 90 H 10 L 10 10" fill="red" />
                             </svg>`;
    var defaultSvg2 = `<svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
                               <path d="M20 20 H 150 V 100 H 20 Z" fill="blue" />
                             </svg>`;

    defaultSvg1 = svg1;
    defaultSvg2 = svg2;
    defaultSvg3 = svg3;

    // Load default SVGs on page load
    $(document).ready(function () {
      // loadSvg(defaultSvg1);
      // loadSvg(defaultSvg2);
      // loadSvg(defaultSvg3);
    });

    // document.getElementById('upload').addEventListener('change', (event) => {
    //   const reader = new FileReader();
    //   reader.onload = function (e) {
    //     loadSvg(e.target.result);
    //   };
    //   reader.readAsText(event.target.files[0]);
    // });

    $('#upload').on('change', function (event) {
      const files = event.target.files;
      Array.from(files).forEach(file => {
        const reader = new FileReader();
        reader.onload = function (e) {
          loadSvg(e.target.result);
        };
        reader.readAsText(file);
      });
    });


    // document.getElementById('loadSvg').addEventListener('click', () => {
    //   const svgData = document.getElementById('svgString').value;
    //   loadSvg(svgData);
    // });

    $('#loadSvg').on('click', function () {
      const svgData = $('#svgString').val();
      loadSvg(svgData);
    });

    // function loadSvg(svg) {
    //   const item = paper.project.importSVG(svg);
    //   polygons.push(item);
    //   item.visible = true;
    // }

    // function loadSvg(svg) {
    //   const item = paper.project.importSVG(svg);
    //   console.log(item);
    //   if (item instanceof paper.Path) {
    //     polygons.push(item);
    //     item.visible = true;
    //   } else if (item instanceof paper.Group) {
    //     item.children.forEach(child => {
    //       if (child instanceof paper.Path) {
    //         polygons.push(child);
    //         child.visible = true;
    //       }
    //     });
    //   }
    // }

    // function loadSvg(svg) {
    //   const item = paper.project.importSVG(svg);

    //   // Log the imported item details
    //   console.log("Imported SVG Item:", item);
    //   console.log("Item Type:", item instanceof paper.Path ? "Path" : item instanceof paper.Group ? "Group" : "Other");


    //   if (item instanceof paper.Path) {
    //     // Check if the path has segments
    //     console.log("Path Length:", item.length);
    //     console.log("Path Segments:", item.segments);
    //     if (item.segments.length === 0) {
    //       console.warn("Warning: Imported Path has no segments.");
    //     } else {
    //       addPathToClipper(item);
    //     }
    //   } else if (item instanceof paper.Group) {
    //     console.log("paper.Group", paper.Group);
    //     console.log("item.children", item.children);

    //     item.children.forEach(child => {
    //       // Check for different types of shapes
    //       if (child instanceof paper.Path ||
    //         child instanceof paper.Shape || // Include Shape if you want
    //         child instanceof paper.Group) { // Allow nested groups
    //         console.log("Child Type:", child instanceof paper.Path ? "Path" : "Shape or Group");
    //         console.log("Child Length:", child.length);
    //         console.log("Child Segments:", child.segments);

    //         if (child instanceof paper.Path && child.segments.length === 0) {
    //           console.warn("Warning: Child Path has no segments.");
    //         } else {
    //           addPathToClipper(child);
    //         }
    //       } else {
    //         console.warn("Warning: Child is not a Path, Shape, or Group.");
    //       }
    //     });
    //   }
    //   item.onMouseDown = onItemMouseDown;
    //   item.onMouseDrag = onItemMouseDrag;
    //   item.onMouseUp = onItemMouseUp;
    // }

    // function loadSvg(svg) {
    //   const item = paper.project.importSVG(svg);

    //   // Log the imported item details
    //   console.log("Imported SVG Item:", item);
    //   console.log("Item Type:", item instanceof paper.Path ? "Path" : item instanceof paper.Group ? "Group" : "Other");

    //   if (item instanceof paper.Path) {
    //     // Log details about the path
    //     console.log("Path Length:", item.length);
    //     console.log("Path Segments:", item.segments);

    //     if (item.segments.length === 0) {
    //       console.warn("Warning: Imported Path has no segments.");
    //     } else {
    //       addPathToClipper(item);
    //     }
    //   } else if (item instanceof paper.Group) {
    //     item.children.forEach(child => {
    //       console.log("Child Type:", child);
    //       // Check for different types of shapes
    //       if (child instanceof paper.Path || child instanceof paper.Shape) {
    //         console.log("Child Length:", child.length);
    //         console.log("Child Segments:", child.segments);

    //         if (child instanceof paper.Path && child.segments.length === 0) {
    //           console.warn("Warning: Child Path has no segments.");
    //         } else {
    //           addPathToClipper(child);
    //         }
    //       } else {
    //         console.warn("Warning: Child is not a Path or Shape. Skipping.");
    //       }
    //     });
    //   }

    //   item.onMouseDown = onItemMouseDown;
    //   item.onMouseDrag = onItemMouseDrag;
    //   item.onMouseUp = onItemMouseUp;
    // }

    function loadSvg(svg) {
      const item = paper.project.importSVG(svg);

      // Log the imported item details
      console.log("Imported SVG Item:", item);
      console.log("Item Type:", item instanceof paper.Path ? "Path" : item instanceof paper.Group ? "Group" : "Other");

      if (item instanceof paper.Path) {
        addPathToClipper(item);
      } else if (item instanceof paper.Group) {
        item.children.forEach(child => {
          console.log("Child Type:", child);

          if (child instanceof paper.Path) {
            addPathToClipper(child);
          } else if (child instanceof paper.Shape) {
            // Convert the shape to a path
            const path = child.toPath();
            if (path) {
              console.log("Converted Shape to Path:", path);
              addPathToClipper(path);
            } else {
              console.warn("Warning: Could not convert shape to path.");
            }
          } else {
            console.warn("Warning: Child is not a Path or Shape. Skipping.");
          }
        });
      }

      item.onMouseDown = onItemMouseDown;
      item.onMouseDrag = onItemMouseDrag;
      item.onMouseUp = onItemMouseUp;
    }


    // function addPathToClipper(path) {
    //   // Log the path for debugging
    //   console.log("Adding Path to Clipper:", path);

    //   // Check if path is valid and has segments
    //   if (path && path instanceof paper.Path && path.segments) {
    //     const clipperPath = path.segments.map(seg => new ClipperLib.IntPoint(seg.point.x, seg.point.y));
    //     if (clipperPath.length > 0) {
    //       polygons.push(path);
    //     } else {
    //       console.warn("Warning: Clipper path is empty.");
    //     }
    //   } else {
    //     console.error("Error: Invalid path or path has no segments.");
    //   }
    // }

    function addPathToClipper(item) {
      // Log the item being added
      console.log("Adding Item to Clipper:", item);

      let clipperPath = [];

      if (item instanceof paper.Path) {
        clipperPath = item.segments.map(seg => new ClipperLib.IntPoint(seg.point.x, seg.point.y));
        console.log("Clipper Path Segments:", clipperPath); // Log the segments
      } else if (item instanceof paper.Shape) {
        // Convert the shape to a path if needed
        const path = item.toPath();
        clipperPath = path.segments.map(seg => new ClipperLib.IntPoint(seg.point.x, seg.point.y));
      }

      if (clipperPath.length > 0) {
        polygons.push(item);
      } else {
        console.warn("Warning: Clipper path is empty.");
      }
    }

    function onItemMouseDown(event) {
      selectedItem = this;
      this.selected = true;
    }

    function onItemMouseDrag(event) {
      if (selectedItem) {
        selectedItem.position.x += event.delta.x;
        selectedItem.position.y += event.delta.y;
      }
    }

    function onItemMouseUp(event) {
      selectedItem.selected = false;
      selectedItem = null;
    }

    function unionTest1() {
      const path1 = 'M100,100 L200,100 L200,200 L100,200 Z';
      const path2 = 'M150,150 L250,150 L250,250 L150,250 Z';

      const clipper = new ClipperLib.Clipper();
      console.log('clipper', clipper);
      console.log('clipperLib.JS', ClipperLib.JS);

      const scale = 2;
      const pathSubject = ClipperLib.JS.ScalePath(ClipperLib.JS.StringToPaths(path1)[0], scale);
      const clipPath = ClipperLib.JS.ScalePath(ClipperLib.JS.StringToPaths(path2)[0], scale);

      const co = new ClipperLib.ClipperOffset();

      co.AddPath(pathSubject, ClipperLib.PolyType.ptSubject, true);
      co.AddPath(clipPath, ClipperLib.PolyType.ptClip, true);

      const solution = new ClipperLib.Paths();
      co.Execute(ClipperLib.ClipType.ctUnion, solution);

      const mergedPath = ClipperLib.JS.PathsToSVG(solution, scale);

      console.log(mergedPath);
    }

    function performBooleanOperation(operation) {
      const clipper = new ClipperLib.Clipper();
      const solution = new ClipperLib.Paths();

      // const paths = polygons.map(item => {
      //   return item.segments.map(seg => new ClipperLib.IntPoint(seg.point.x, seg.point.y));
      // });

      // Collect paths for clipping
      const paths = polygons.map(item => {
        return item.segments.map(seg => new ClipperLib.IntPoint(seg.point.x, seg.point.y));
      }).filter(path => path.length > 0); // Filter out any empty paths

      if (paths.length === 0) {
        console.log("No paths to process");
        return;
      }

      clipper.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);

      switch (operation) {
        case 'union':
          clipper.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
          console.log("Union Result:", solution); // Log the result of the union
          break;
        case 'difference':
          clipper.Execute(ClipperLib.ClipType.ctDifference, solution, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
          console.log("difference Result:", solution); // Log the result of the difference
          break;
        case 'intersection':
          clipper.Execute(ClipperLib.ClipType.ctIntersection, solution, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
          console.log("intersection Result:", solution); // Log the result of the intersection
          break;
        case 'subtraction':
          clipper.Execute(ClipperLib.ClipType.ctDifference, solution, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
          console.log("subtraction Result:", solution); // Log the result of the subtraction
          break;
      }

      // Check if the solution has paths
      if (solution.length === 0) {
        console.log("No solution found");
        return;
      }

      console.log("solution", solution);

      // solution.forEach(path => {
      //   const newPath = new paper.Path();
      //   path.forEach(point => newPath.add(new paper.Point(point.X, point.Y)));
      //   newPath.closed = true;
      //   newPath.fillColor = new paper.Color(Math.random(), Math.random(), Math.random());
      // });

      // Draw original polygons
      paper.project.activeLayer.removeChildren();
      polygons.forEach(path => {
        const newPath = new paper.Path();
        path.segments.forEach(seg => newPath.add(seg.point));
        newPath.closed = true; // Ensure the path is closed
        newPath.fillColor = path.fillColor; // Retain original color
      });

      // Draw the result of the operation
      solution.forEach(path => {
        const newPath = new paper.Path();
        path.forEach(point => newPath.add(new paper.Point(point.X, point.Y)));
        newPath.closed = true;// Ensure the path is closed
        newPath.fillColor = new paper.Color(Math.random(), Math.random(), Math.random());
      });
    }

    document.getElementById('union').addEventListener('click', () => performBooleanOperation('union'));
    document.getElementById('difference').addEventListener('click', () => performBooleanOperation('difference'));
    document.getElementById('intersection').addEventListener('click', () => performBooleanOperation('intersection'));
    document.getElementById('subtraction').addEventListener('click', () => performBooleanOperation('subtraction'));
    document.getElementById('union2').addEventListener('click', () => unionTest1());
  </script>
</body>

</html>